<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Abt (um-abt.Abt)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">um-abt</a> &#x00BB; Abt</nav><h1>Module <code>Abt</code></h1><h2 id="overview"><a href="#overview" class="anchor"></a>Overview</h2><p><code>um-abt</code> is a library for representing and manipulating the the syntax of languages that use <a href="Var/index.html"><span>variables</span></a>.</p><p><code>um-abt</code> provides abstract binding trees (ABTs). An abstract binding tree is an <i>abstract syntax tree</i>, enriched with constructs to manage variable binding and scope.</p><p><code>um-abt</code> also supports <a href="Make/Unification/index.html"><span>unification</span></a> over ABTs.</p><h2 id="example"><a href="#example" class="anchor"></a>Example</h2><p>A typical example of a module satisfying this interface, used to represent the syntax of the untyped lambda calculus:</p><pre><code class="ml">module O = struct
  type 'a t =
    | App of 'a * 'a
    | Lam of 'a
  [@@deriving eq, map, fold]

  let to_string : string t -&gt; string = function
    | App (l, m) -&gt; Printf.sprintf &quot;(%s %s)&quot; l m
    | Lam abs    -&gt; Printf.sprintf &quot;(λ%s)&quot; abs
end

include Abt.Make (O)</code></pre><p>Note the use of <a href="https://github.com/ocaml-ppx/ppx_deriving">ppx_deriving</a> to derive most values automatically.</p><nav class="toc"><ul><li><a href="#interfaces">Interfaces</a></li><li><a href="#top-level-modules">Top-level modules</a></li></ul></nav></header><section><header><h2 id="interfaces"><a href="#interfaces" class="anchor"></a>Interfaces</h2></header><dl><dt class="spec module-type" id="module-type-Operator"><a href="#module-type-Operator" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Operator/index.html">Operator</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The interface for a module that defines the operators of a language</p></dd></dl></section><section><header><h2 id="top-level-modules"><a href="#top-level-modules" class="anchor"></a>Top-level modules</h2></header><dl><dt class="spec module" id="module-Var"><a href="#module-Var" class="anchor"></a><code><span class="keyword">module</span> <a href="Var/index.html">Var</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Variables, named by strings, which can be bound to a <a href="Var/Binding/index.html"><code>Var.Binding</code></a> or left free.</p></dd></dl><div class="spec module-type" id="module-type-Syntax"><a href="#module-type-Syntax" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Syntax/index.html">Syntax</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec module" id="module-Make"><a href="#module-Make" class="anchor"></a><code><span class="keyword">module</span> <a href="Make/index.html">Make</a> : <span class="keyword">functor</span> (<a href="Make/argument-1-Op/index.html">Op</a> : <a href="index.html#module-type-Operator">Operator</a>) <span>&#45;&gt;</span> <a href="index.html#module-type-Syntax">Syntax</a> <span class="keyword">with</span> <span class="keyword">module</span> <a href="Make/Op/index.html">Op</a> = <a href="Make/index.html#argument-1-Op">Op</a></code></dt><dd><p><code>Make (Op)</code> is a module for constructing and manipulating the <code>Syntax</code> of a language with <code>Operator</code>s defined by <code>Op</code>.</p></dd></dl></section></div></body></html>